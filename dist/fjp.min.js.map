{"version":3,"file":"fjp.min.js","sources":["../source/util/clone/index.js","../source/util/isArray/index.js","../source/util/isFunction/index.js","../source/util/isString/index.js","../source/curry/index.js","../source/util/tap/index.js","../source/combinators/A/index.js","../source/combinators/I/index.js","../source/combinators/K/index.js","../source/combinators/OR/index.js","../source/combinators/Fork/index.js","../source/combinators/T/index.js","../source/monads/Maybe/index.js","../source/monads/Either/index.js","../source/monads/IO/index.js","../source/every/index.js","../source/associate/index.js","../source/altAssociate/index.js","../source/reduce/index.js","../source/sum/index.js","../source/concat/index.js","../source/deviation/index.js","../source/difference/index.js","../source/distinctFn/index.js","../source/each/index.js","../source/filter/index.js","../source/find/index.js","../source/findIndex/index.js","../source/flatten/index.js","../source/groupBy/index.js","../source/intersection/index.js","../source/join/index.js","../source/map/index.js","../source/merge/index.js","../source/occurrence/index.js","../source/property/index.js","../source/push/index.js","../source/reduceRight/index.js","../source/select/index.js","../source/slice/index.js","../source/some/index.js","../source/sort/index.js","../source/symmetricDifference/index.js","../source/union/index.js","../source/unshift/index.js","../source/average/index.js","../source/both/index.js","../source/compact/index.js","../source/compose/index.js","../source/concatN/index.js","../source/distinct/index.js","../source/distinctN/index.js","../source/util/isNumber/index.js","../source/util/isObject/index.js","../source/util/not/index.js","../source/partial/index.js","../source/pipe/index.js","../source/pop/index.js","../source/promisify/index.js","../source/reverse/index.js","../source/shift/index.js","../source/shuffle/index.js","../source/sumN/index.js"],"sourcesContent":["/* eslint-disable fp-jxl/no-let, fp-jxl/no-loops, fp-jxl/no-mutation */\n\nfunction clone(x) {\n  // eslint-disable-next-line fp-jxl/no-nil\n  let i;\n\n  if(!x || typeof x !== 'object') {\n    return x;\n  }\n\n  if(x instanceof Date) {\n    return new Date(x);\n  }\n\n  if(Array.isArray(x)) {\n    const arr = [];\n\n    for(i = 0; i < x.length; i += 1) {\n      arr[i] = clone(x[i]);\n    }\n\n    return arr;\n  }\n\n  if(x instanceof Object && x.constructor === Object) {\n    const obj = {};\n\n    for(i in x) {\n      if(x.hasOwnProperty(i)) {\n        obj[i] = clone(x[i]);\n      }\n    }\n\n    return obj;\n  }\n\n  return x;\n}\n\nexport default clone;\n","/**\n * Determines if the given value is an array.\n * @signature isArray :: a -> Boolean\n * @func\n * @example\n * isArray([1, 2, 3])  // true\n * isArray({ a: 'b' })  // false\n */\nconst isArray = value => Array.isArray(value);\n\nexport default isArray;\n","/**\n * Determines if the given value is a function.\n * @signature isFunction :: a -> Boolean\n * @func\n * @example\n * isFunction(() => {})  // true\n * isFunction([1, 2, 3])  // false\n */\nconst isFunction = value => typeof value === 'function';\n\nexport default isFunction;\n","/**\n * Determines if the given value is a string.\n * @signature isString :: a -> Boolean\n * @func\n * @example\n * isString('foo bar')  // true\n * isString({ a: 'b' })  // false\n */\nconst isString = value => value != null && value.constructor === String;\n\nexport default isString;\n","/* eslint-disable fp-jxl/no-nil */\n/**\n * Wraps the given function, if the number of provided args is sufficient, call the passed function fn.\n * Otherwise, return a wrapped function fn that expects the rest of the arguments.\n * If you want to curry a function that accepts a variable number of arguments (a variadic function),\n * you can optionally pass the number of arguments to the second parameter arity.\n * @signature curry :: ((a, b, ..., n) -> m) -> a -> b -> ...n -> m\n * @func\n * @example\n * const add = curry((x, y) => x + y);\n * const addFiveTo = add(5);\n * addFiveTo(10); // 15\n */\nfunction curry(fn, arity = fn.length, ...args) {\n  return arity <= args.length ? fn(...args) : curry.bind(null, fn, arity, ...args);\n}\n\nexport default curry;\n","/* eslint-disable fp-jxl/no-unused-expression */\nimport curry from '../../curry';\n\n/**\n * Calls the given function with the given value and returns the value.\n * @signature tap :: (a -> b) -> a -> a\n * @func\n * @example\n * tap(console.log, 'foobar') // foobar\n */\nconst tap = curry((x, y) => {\n  x(y);\n  return y;\n});\n\nexport default tap;\n","import curry from '../../curry';\n\n/**\n * Calls the given function with the given value.\n * @signature A :: (a -> b) -> a -> b\n * @func\n * @aka apply\n */\nconst A = curry((f, x) => f(x));\n\nexport default A;\n","/**\n * Returns the given value.\n * @signature I :: a -> a\n * @func\n * @aka identity\n */\nconst I = x => x;\n\nexport default I;\n","/* eslint-disable no-unused-vars */\nimport curry from '../../curry';\n\n/**\n * Takes two values and returns the given first.\n * @signature K :: a -> b -> a\n * @func\n * @aka constant\n */\nconst K = curry((x, y) => x);\n\nexport default K;\n","import curry from '../../curry';\n\n/**\n * Given two functions that take the same value, returns the first if the result is truthy, otherwise, the second.\n * @signature OR :: (a -> b) -> (a -> b) -> b\n * @func\n * @aka alternation\n */\nconst OR = curry((f, g) => x => f(x) || g(x));\n\nexport default OR;\n","import curry from '../../curry';\n\n/**\n * Takes a joiner func, and two other funcs and a value. The value is given to both funcs and the\n * results of each of these is given to the joiner func.\n * @signature Fork :: (b -> c -> d) -> (a -> b) -> (a -> c) -> a -> d\n * @func\n * @aka join\n */\nconst Fork = curry((joiner, fnA, fnB, x) => joiner(fnA(x), fnB(x)));\n\nexport default Fork;\n","import curry from '../../curry';\n\n/**\n * Calls the given function with the given value. (Reverse order of apply)\n * @signature T :: a -> (a -> b) -> b\n * @func\n * @aka thrush, applyTo\n */\nconst T = curry((x, f) => f(x));\n\nexport default T;\n","/* eslint-disable fp-jxl/no-this, fp-jxl/no-class, fp-jxl/no-mutation */\n\nclass Maybe {\n  static of(x) {\n    // eslint-disable-next-line no-use-before-define\n    return x !== undefined && x !== null ? new Just(x) : new Nothing();\n  }\n\n  static Just(x) {\n    // eslint-disable-next-line no-use-before-define\n    return new Just(x);\n  }\n\n  static None() {\n    // eslint-disable-next-line no-use-before-define\n    return new Nothing();\n  }\n\n  static fromNullable(x) {\n    return Maybe.of(x);\n  }\n\n  static lift(fn, x) {\n    return Maybe.of(x).map(fn);\n  }\n\n  get isNothing() {\n    return false;\n  }\n\n  get isJust() {\n    return false;\n  }\n\n  flatten() {\n    return this;\n  }\n\n  join() {\n    return this;\n  }\n\n  filter() {\n    return this;\n  }\n\n  map() {\n    return this;\n  }\n\n  chain(fn) {\n    return this.map(fn).flatten();\n  }\n}\n\nclass Just extends Maybe {\n  // eslint-disable-next-line fp-jxl/no-nil\n  constructor(val) {\n    super();\n    this._val = val;\n  }\n\n  get value() {\n    return this._val;\n  }\n\n  get isJust() {\n    return true;\n  }\n\n  map(fn) {\n    return Maybe.of(fn(this._val));\n  }\n\n  flatten() {\n    if(!(this._val instanceof Just)) {\n      return this;\n    }\n\n    return this._val.flatten();\n  }\n\n  join() {\n    return this.flatten();\n  }\n\n  orElse() {\n    return this._val;\n  }\n\n  filter(fn) {\n    // eslint-disable-next-line fp-jxl/no-nil\n    return Maybe.of(fn(this._val) ? this._val : null);\n  }\n\n  toString() {\n    return `Maybe.Just(${ this._val })`;\n  }\n}\n\nclass Nothing extends Maybe {\n  // eslint-disable-next-line fp-jxl/no-nil\n  constructor() {\n    super();\n  }\n\n  // eslint-disable-next-line fp-jxl/no-nil\n  get value() {\n    // eslint-disable-next-line fp-jxl/no-throw\n    throw new TypeError(\"Can't extract the value of a Nothing\");\n  }\n\n  get isNothing() {\n    return true;\n  }\n\n  orElse(other) {\n    return other;\n  }\n\n  toString() {\n    return 'Maybe.Nothing';\n  }\n}\n\nexport default Maybe;\n","/* eslint-disable fp-jxl/no-this, fp-jxl/no-class, fp-jxl/no-mutation */\nimport Maybe from '../Maybe';\n\nclass Either {\n  static of(x) {\n    // eslint-disable-next-line no-use-before-define\n    return x !== undefined && x !== null && !(x instanceof Error) ?\n      new Right(x) : // eslint-disable-line no-use-before-define\n      new Left(x); // eslint-disable-line no-use-before-define\n  }\n\n  static fromNullable(x) {\n    return Either.of(x);\n  }\n\n  static Right(x) {\n    // eslint-disable-next-line no-use-before-define\n    return new Right(x);\n  }\n\n  static Left(x) {\n    // eslint-disable-next-line no-use-before-define\n    return new Left(x);\n  }\n\n  // eslint-disable-next-line fp-jxl/no-nil\n  static try(fn) {\n    try {\n      // eslint-disable-next-line callback-return\n      const result = fn();\n\n      return Either.of(result);\n    }\n    catch(e) {\n      // eslint-disable-next-line new-cap\n      return Either.Left(e);\n    }\n  }\n\n  get isRight() {\n    return false;\n  }\n\n  get isLeft() {\n    return false;\n  }\n\n  get value() {\n    return this._val;\n  }\n\n  join() {\n    if(this.value instanceof Either) {\n      return this.value.join();\n    }\n\n    return this;\n  }\n\n  map(fn) {\n    return Either.of(fn(this._val));\n  }\n\n  flatMap(fn) {\n    return this.map(fn).join();\n  }\n\n  filter() {\n    return this;\n  }\n\n  chain(fn) {\n    return this.isRight ? fn(this._val) : this;\n  }\n\n  cata(leftFn, rightFn) {\n    return this.isRight ? rightFn(this._val) : leftFn(this._val);\n  }\n\n  orElseFn() {\n    return this;\n  }\n\n  toMaybe() {\n    return this.cata(Maybe.None, Maybe.Just);\n  }\n}\n\nclass Right extends Either {\n  // eslint-disable-next-line fp-jxl/no-nil\n  constructor(val) {\n    super();\n    this._val = val;\n  }\n\n  get isRight() {\n    return true;\n  }\n\n  filter(fn) {\n    // eslint-disable-next-line fp-jxl/no-nil\n    return Either.of(fn(this._val) ? this._val : null);\n  }\n\n  orElse() {\n    return this._val;\n  }\n\n  async asyncChain(fn) {\n    return await fn(this._val);\n  }\n\n  toString() {\n    return `Either.Right(${ this.value })`;\n  }\n}\n\nclass Left extends Either {\n  // eslint-disable-next-line fp-jxl/no-nil\n  constructor(val) {\n    super();\n    this._val = val;\n  }\n\n  get isLeft() {\n    return true;\n  }\n\n  orElse(other) {\n    return other;\n  }\n\n  orElseFn(fn) {\n    return fn(this._val);\n  }\n\n  toString() {\n    return `Either.Left(${ this._val })`;\n  }\n}\n\nexport default Either;\n","/* eslint-disable fp-jxl/no-this, fp-jxl/no-class, fp-jxl/no-mutation */\nimport isFunction from '../../util/isFunction';\n\nclass IO {\n  // eslint-disable-next-line fp-jxl/no-nil\n  constructor(effect) {\n    if(!isFunction(effect)) {\n      // eslint-disable-next-line fp-jxl/no-throw\n      throw new Error('effect needs to be a function');\n    }\n\n    this._effect = effect;\n  }\n\n  static of(val) {\n    return new IO(() => val);\n  }\n\n  static from(fn) {\n    return new IO(fn);\n  }\n\n  map(fn) {\n    return new IO(() => fn(this._effect()));\n  }\n\n  chain(fn) {\n    return fn(this._effect());\n  }\n\n  run() {\n    return this._effect();\n  }\n}\n\nexport default IO;\n","import curry from '../curry';\nimport isFunction from '../util/isFunction';\nimport isArray from '../util/isArray';\n\n/**\n * Determines if all element in an array satisfy the given test function\n * @signature every :: (a -> Bool) -> [a] -> Bool\n * @func\n * @aka all\n * @example\n * every(Boolean, [1, 2, 3, 4]) // true\n * every(Boolean, [1, 2, null, 4]) // false\n */\nconst every = curry((fn, arr) => isArray(arr) && isFunction(fn) ? arr.every(fn) : false);\n\nexport default every;\n","/* eslint-disable fp-jxl/no-mutation */\nimport curry from '../curry';\nimport clone from '../util/clone';\n\n/**\n * Sets the given property and value on the object. Returning a new object.\n * @signature associate :: String k -> {} -> v -> {k: v}\n * @func\n * @example\n * const obj = associate('c', { a: b }, d)  // { a: b, c: d }\n */\nconst associate = curry((prop, obj, val) => {\n  const c = clone(obj);\n\n  c[prop] = val;\n  return c;\n});\n\nexport default associate;\n","import curry from '../curry';\nimport assoc from '../associate';\n\nconst altAssoc = curry((prop, val, obj) => assoc(prop, obj, val));\n\nexport default altAssoc;\n","import curry from '../curry';\nimport isFunction from '../util/isFunction';\nimport isArray from '../util/isArray';\nimport clone from '../util/clone';\n\nexport default curry((init, fn, arr) =>\n  !isFunction(fn) ?\n    isArray(arr) ?\n      clone(arr) :\n      [] :\n    isArray(arr) ?\n      clone(arr.reduce(fn, init)) :\n      []);\n","import isArray from '../util/isArray';\nimport curry from '../curry';\nimport reduce from '../reduce';\n\nexport default curry(arr => isArray(arr) ? reduce(0, (acc, val) => acc + Number(val), arr) : 0);\n","import isArray from '../util/isArray';\nimport isString from '../util/isString';\nimport curry from '../curry';\n\n/**\n * Concatenates two String|Arrays together.\n * Returns empty array if value arent of the same type or not String|Array.\n * @signature concat :: a -> b -> c\n * @func\n * @example\n * concat('foo', 'bar') // foobar\n * concat([1, 2], [3, 4]) // [1, 2, 3, 4]\n */\nconst concat = curry((a, b) =>\n  isArray(a) && isArray(b) ? [ ...a, ...b ] : isString(a) && isString(b) ? `${ a }${ b }` : []);\n\nexport default concat;\n","import curry from '../curry';\n\n// Returns the standard deviation of an array of numbers.\n//\n// deviation([ 10, 2, 38, 23, 38, 23, 21 ]);\n// >> 13.284434142114991 (sample)\n//\n// deviation([ 10, 2, 38, 23, 38, 23, 21 ], true);\n// >> 12.29899614287479 (population)\n//\nconst deviation = curry((usePopulation, arr) => {\n  const mean = arr.reduce((acc, val) => acc + val, 0) / arr.length;\n\n  return Math.sqrt(arr\n    .reduce((acc, val) => acc.concat(Math.pow(val - mean, 2)), [])\n    .reduce((acc, val) => acc + val, 0) /\n      (arr.length - (usePopulation ? 0 : 1)));\n});\n\nexport default deviation;\n","import curry from '../curry';\nimport isArray from '../util/isArray';\n\n/**\n * Returns the difference between two arrays.\n * @signature difference :: [a] -> [b] -> [c]\n * @func\n * @example\n * difference([ 1, 2, 3 ], [ 1, 2, 4 ]) // [3]\n * difference([], [ 1, 2, 4 ]) // [ 1, 2, 4 ]\n * difference([ 1, 2, 3 ], []) // [ 1, 2, 3 ]\n * difference([ 1, 2, 3 ], null) // [ 1, 2, 3 ]\n */\nconst difference = curry((a, b) => {\n  const s = isArray(b) && b.length ? new Set(b) : new Set();\n\n  return isArray(a) && a.length ? a.filter(x => !s.has(x)) : [...s];\n});\n\nexport default difference;\n","import isFunction from '../util/isFunction';\nimport isArray from '../util/isArray';\nimport curry from '../curry';\n\nexport default curry((func, arr) =>\n  isArray(arr) ? isFunction(func) ? [...new Set(arr.map(func))] : [...new Set(arr)] : []);\n","import curry from '../curry';\n\n/**\n * Applies the given func to each element in the array.\n * @signature each :: (a -> b) -> [c] -> undefined\n * @func\n * @example\n * difference(log, [1, 2, 3])\n */\nconst each = curry((fn, arr) => arr.forEach(fn));\n\nexport default each;\n","import curry from '../curry';\nimport clone from '../util/clone';\nimport isFunction from '../util/isFunction';\nimport isArray from '../util/isArray';\n\n/**\n * Filters the array using the given function.\n * @signature filter :: (a -> Boolean) -> [a] -> [a]\n * @func\n * @example\n * filter(x => x > 5, [1, 2, 3, 5, 6, 7]) // [6, 7]\n */\nconst filter = curry((func, arr) =>\n  !isFunction(func) ? isArray(arr) ? clone(arr) : [] : isArray(arr) ? arr.filter(func) : []);\n\nexport default filter;\n","import curry from '../curry';\n\n/**\n * Finds the first element that satisfies the given test func.\n * @signature find :: (a -> Boolean) -> [a] -> a\n * @func\n * @example\n * find(x => x.score === 5, [{score: 1}, {score: 2}, {score: 5}, {score: 6}, {score: 7}]) // {score: 5}\n */\nconst find = curry((fn, x) => x.find(fn));\n\nexport default find;\n","import curry from '../curry';\n\nexport default curry((fn, x) => x.findIndex(fn));\n","import reduce from '../reduce';\n\n/* eslint-disable array-bracket-newline, array-element-newline */\nconst flatten = reduce((acc, curr) => [ ...acc, ...curr ], []);\n\nexport default flatten;\n","/* eslint-disable fp-jxl/no-mutation */\nimport curry from '../curry';\nimport isFunction from '../util/isFunction';\nimport isArray from '../util/isArray';\n\n// Groups the elements of an array based on the given function.\n//\n// groupBy(Math.floor, [ 6.1, 4.2, 6.3 ]);\n// >> { '4': [4.2], '6': [ 6.1, 6.3 ] }\n//\n// groupBy('length', [ 'one', 'two', 'three' ]);\n// >> { '3': [ 'one', 'two' ], '5': ['three'] }\n//\n// groupBy(null, ['one', 'two', 'three']);\n// >> {}\n//\n// groupBy(Math.floor, null);\n// >> {}\n//\nexport default curry((func, arr) =>\n  func != null && isArray(arr) ?\n    arr.map(isFunction(func) ? func : val => val[func]).reduce((acc, val, i) => {\n      acc[val] = (acc[val] || []).concat(arr[i]);\n      return acc;\n    }, {}) :\n    {});\n","import curry from '../curry';\nimport isArray from '../util/isArray';\n\n// Returns a list of elements that exist in both arrays.\n//\n// intersection([ 1, 2, 3 ], [ 4, 3, 2 ]);\n// >> [ 2,3 ]\n//\nexport default curry((a, b) => {\n  const s = isArray(b) ? new Set(b) : new Set();\n\n  return isArray(a) ? a.filter(x => s.has(x)) : [...s];\n});\n","import curry from '../curry';\n\nexport default curry((sep, arr) => arr.join(sep));\n","import curry from '../curry';\nimport isFunction from '../util/isFunction';\nimport isArray from '../util/isArray';\nimport clone from '../util/clone';\n\nexport default curry((func, arr) =>\n  !isFunction(func) ? isArray(arr) ? clone(arr) : [] : isArray(arr) ? arr.map(func) : []);\n","import curry from '../curry';\nimport clone from '../util/clone';\n\nexport default curry((a, b) => Object.assign({}, clone(a), clone(b)));\n","import curry from '../curry';\nimport isArray from '../util/isArray';\n\n// Counts the occurrences of a value in an array.\n//\n// occurrences(1, [ 1, 1, 2, 1, 2, 3 ]);\n// >> 3\n//\nexport default curry((value, arr) =>\n  isArray(arr) ? arr.reduce((acc, val) => val === value ? acc + 1 : acc, 0) : 0);\n","import curry from '../curry';\nimport clone from '../util/clone';\n\nexport default curry((prop, obj) => clone(obj[prop]));\n","import curry from '../curry';\nimport isArray from '../util/isArray';\nimport clone from '../util/clone';\n\n// push(5, [ 1, 2, 3, 4 ]);\n// >> [ 1, 2, 3, 4, 5 ]\n//\n// push(5)\n// >> [5]\n//\nexport default curry((val, arr) => isArray(arr) ? [ ...clone(arr), val ] : [val]);\n","import curry from '../curry';\nimport isFunction from '../util/isFunction';\nimport isArray from '../util/isArray';\nimport clone from '../util/clone';\n\nexport default curry((init, fn, arr) =>\n  !isFunction(fn) ?\n    isArray(arr) ?\n      clone(arr) :\n      [] :\n    isArray(arr) ?\n      clone(arr.reduceRight(fn, init)) :\n      []);\n","/* eslint-disable fp-jxl/no-unused-expression, fp-jxl/no-mutation */\nimport curry from '../curry';\n\n// Selects the key-value pairs corresponding to the given keys from an object.\n//\n// select([ 'a', 'c.d' ], { a: 1, b: '2', c: { d: 3 } });\n// >> { a: 1, d: 3 }\n//\nconst select = (arr, obj) =>\n  arr.reduce((acc, curr) => {\n    const split = curr.split('.');\n\n    // This will return the full path => 'a.b' == a: { b: val }\n    // (acc[split[0]] = select(obj[split[0]], [split.slice(1).join('.')]), acc) :\n\n    /* eslint-disable no-return-assign */\n    // This will return just the nested value => 'a.b' == b: val\n    return split.length > 1 ?\n      acc[split[0]] = select(obj[split[0]], [split.slice(1).join('.')]) :\n      (curr in obj && (acc[curr] = obj[curr]), acc);\n  }, {});\n\nexport default curry(select);\n","import curry from '../curry';\nimport isArray from '../util/isArray';\nimport clone from '../util/clone';\n\n// TODO: also call subset\nexport default curry((start, end, arr) => isArray(arr) ? clone(arr).slice(start, end) : []);\n","import curry from '../curry';\nimport isFunction from '../util/isFunction';\nimport isArray from '../util/isArray';\n\n// TODO: Bench against\n// export default curry((fn, array) => array.reduce((acc, curr) => fn(curr) || acc, false));\n\nconst some = curry((fn, arr) => isArray(arr) && isFunction(fn) ? arr.some(fn) : false);\n\nexport default some;\n","import curry from '../curry';\nimport isFunction from '../util/isFunction';\nimport isArray from '../util/isArray';\nimport clone from '../util/clone';\n\nexport default curry((fn, arr) =>\n  !isFunction(fn) ? isArray(arr) ? clone(arr) : [] : isArray(arr) ? clone(arr).sort(fn) : []);\n","import curry from '../curry';\nimport isArray from '../util/isArray';\n\n// Returns the symmetric difference between two arrays.\n//\n// symmetricDifference([ 1, 2, 3 ], [ 1, 2, 4 ]);\n// >> [ 3, 4 ]\n//\nexport default curry((a, b) => {\n  const sA = isArray(a) ? new Set(a) : new Set();\n  const sB = isArray(b) ? new Set(b) : new Set();\n\n  return [ ...a.filter(x => !sB.has(x)), ...b.filter(x => !sA.has(x)) ];\n});\n","import curry from '../curry';\nimport isArray from '../util/isArray';\n\n// Returns every element that exists in any of the two arrays once.\n//\n// union([ 1, 2, 3 ], [ 4, 3, 2 ]);\n// >> [ 1, 2, 3, 4 ]\n//\nexport default curry((a, b) =>\n  Array.from(new Set([ ...isArray(a) ? a : [], ...isArray(b) ? b : [] ])));\n","import curry from '../curry';\nimport isArray from '../util/isArray';\nimport clone from '../util/clone';\n\n// unshift(0, [ 1, 2, 3, 4 ])\n// >> [ 0, 1, 2, 3, 4 ]\n//\n// unshift(0)\n// >> [0]\n//\nexport default curry((val, arr) => isArray(arr) ? [ val, ...clone(arr) ] : [val]);\n","import isArray from '../util/isArray';\nimport sum from '../sum';\n\n/**\n * Averages the given array values\n * @signature average :: [Number] -> Number\n * @func\n * @example\n * average([ 1, 2, 3 ]); // 2\n * average(1, 2, 3); // 2\n * average(); // 0\n */\nconst average = (...nums) => isArray(nums) && nums.length ? sum([...nums]) / [...nums].length : 0;\n\nexport default average;\n","const both = (f, g) => x => f(x) && g(x);\n\nexport default both;\n","import isArray from '../util/isArray';\n\n/**\n * Removes falsey values from an array.\n * @signature compact :: [a] -> [a]\n * @func\n * @example\n * compact([ 0, 1, false, 2, '', 3, 'a', 'e' * 23, NaN, 's', 34 ]); // [ 1, 2, 3, 'a', 's', 34 ]\n * compact(null) // []\n */\nconst compact = arr => isArray(arr) ? arr.filter(Boolean) : [];\n\nexport default compact;\n","/**\n * Performs right-to-left function composition.\n * @signature compose :: [(m -> n), ..., (b -> c), (a -> b)] -> a -> n\n * @func\n * @example\n * const addOne = x => x + 1;\n * const timeTen = x => x * 10;\n * const addOneTimeTen = compose(timeTen, addOne);\n * const result = addOneTimeTen(9); // 100\n */\nconst compose = (...fns) =>\n  fns.reduce((f, g) =>\n    (...args) =>\n      f(g(...args)));\n\nexport default compose;\n","import reduce from '../reduce';\n\n/**\n * Concatenates N Arrays together.\n * @signature concat :: [a] -> [b] -> ...[n] -> [m]\n * @func\n * @example\n * concatN([1, 2], [3, 4], [5, 6]) // [1, 2, 3, 4, 5, 6]\n */\nconst concatN = (...args) => reduce([], (acc, val) => [ ...acc, ...val ], args);\n\nexport default concatN;\n","import isArray from '../util/isArray';\n\n/**\n * Returns all of the distinct values of an array.\n * @signature distinct :: [a] -> [b]\n * @func\n * @example\n * distinct([ 1, 2, 2, 3, 4, 4, 5 ]) // [ 1, 2, 3, 4, 5 ]\n */\nconst distinct = arr => isArray(arr) ? [...new Set(arr)] : [];\n\nexport default distinct;\n","/**\n * Returns all of the distinct values of the given arrays.\n * @signature distinctN :: [a] -> [b] -> ...[n] -> [m]\n * @func\n * @example\n * distinctN([ 1, 2 ], [ 2, 3, 4 ], [ 4, 5 ]) // [ 1, 2, 3, 4, 5 ]\n */\nconst distinctN = (...args) => [...new Set(...args)];\n\nexport default distinctN;\n","/**\n * Determines if the given value is a number.\n * @signature isNumber :: a -> Boolean\n * @func\n * @example\n * isNumber(42)  // true\n * isNumber(8e5)  // true\n * isNumber(0x2F)  // true\n * isNumber('foo bar')  // false\n */\nconst isNumber = n => !isNaN(parseFloat(n)) && isFinite(n);\n\nexport default isNumber;\n","/**\n * Determines if the given value is an object.\n * @signature isObject :: a -> Boolean\n * @func\n * @example\n * isObject({ a: 'b' })  // true\n * isObject([1, 2, 3])  // false\n */\nconst isObject = value => value != null && !Array.isArray(value) && typeof value === 'object';\n\nexport default isObject;\n","/**\n * Negates the given boolean-like value.\n * @signature not :: Boolean -> Boolean\n * @func\n * @example\n * not(true); // false\n * not(false); // true\n * not(2); // false\n */\nconst not = x => !x;\n\nexport default not;\n","const partial =\n  (fn, ...partialArgs) =>\n    (...remainingArgs) =>\n      fn(...partialArgs, ...remainingArgs);\n\nexport default partial;\n","// Performs left-to-right function composition.\n// The first (leftmost) function can accept one or more arguments; the remaining functions must be unary.\n//\n// const add5 = x => x + 5;\n// const multiply = (x, y) => x * y;\n// const multiplyAndAdd5 = pipe(multiply, add5);\n// multiplyAndAdd5(5, 2);\n//\n// >> 15\n//\nconst pipe = (...fns) =>\n  fns.reduce((f, g) =>\n    (...args) =>\n      g(f(...args)));\n\nexport default pipe;\n","import isArray from '../util/isArray';\nimport clone from '../util/clone';\n\n// May be slightly unconventional but given you can only return one value\n// which of the two things that pop does is more important?\n// Removing the item from the array or returning that item\n// I chose removing the item\n\n// pop([ 1, 2, 3, 4, 5 ]);\n// >> [ 1, 2, 3, 4 ]\n//\n// pop([1]);\n// >> []\n//\n// pop();\n// >> []\n//\nconst pop = arr => !isArray(arr) || !arr.length ? [] : clone(arr).slice(0, arr.length - 1);\n\nexport default pop;\n","/* eslint-disable promise/prefer-await-to-callbacks */\n\n// Converts an asynchronous function to return a promise.\n// Use currying to return a function returning a Promise that calls the original function.\n// Use the ...rest operator to pass in all the parameters.\n//\n// const delay = promisify((d, cb) => setTimeout(cb, d));\n// delay(2000).then(() => console.log('Hi!'));\n//\nconst promisify =\n  func =>\n    (...args) =>\n      new Promise((resolve, reject) =>\n        func(...args, (err, result) => err ? reject(err) : resolve(result)));\n\nexport default promisify;\n","import isArray from '../util/isArray';\nimport clone from '../util/clone';\n\nconst reverse = arr => isArray(arr) ? clone(arr).reverse() : [];\n\nexport default reverse;\n","import isArray from '../util/isArray';\nimport clone from '../util/clone';\n\n// May be slightly unconventional but given you can only return one value\n// which of the two things that pop does is more important?\n// Removing the item from the array or returning that item\n// I choose removing the item\n\n// shift([ 1, 2, 3, 4, 5 ]);\n// >> [ 2, 3, 4, 5 ]\n//\n// shift([1]);\n// >> []\n//\n// shift();\n// >> []\n//\nconst shift = arr => !isArray(arr) || !arr.length ? [] : clone(arr).slice(1);\n\nexport default shift;\n","/* eslint-disable fp-jxl/no-let, fp-jxl/no-loops, fp-jxl/no-mutation  */\nimport clone from '../util/clone';\n\n// Randomizes the order of the values of an array, returning a new array.\n// Uses the Fisher-Yates algoritm to reorder the elements of the array.\n//\n// shuffle([ 1, 2, 3 ]);\n// >> [ 2, 3, 1 ]\n//\nconst shuffle = ([...arr]) => {\n  const carr = clone(arr);\n\n  let m = carr.length;\n\n  while(m) {\n    const i = Math.floor(Math.random() * m--);\n\n    [ carr[m], carr[i] ] = [ carr[i], carr[m] ];\n  }\n\n  return carr;\n};\n\nexport default shuffle;\n","import isArray from '../util/isArray';\nimport reduce from '../reduce';\n\n// Returns the sum of two or more numbers or an array of numbers.\n//\n// sum([ 1, 2, 3, 4 ]);\n// >> 10\n//\n// sum(1, 2, 3, 4);\n// >> 10\n//\nconst sumN = (...nums) =>\n  isArray(nums) ? reduce(0, (acc, val) => acc + Number(val), [].concat(...nums)) : 0;\n\nexport default sumN;\n"],"names":["clone","x","i","babelHelpers","Date","Array","isArray","arr","length","Object","constructor","obj","hasOwnProperty","value","isFunction","isString","String","curry","fn","arity","arguments","undefined","_len","args","_key","apply","bind","tap","y","A","f","I","K","OR","g","Fork","joiner","fnA","fnB","T","Maybe","this","map","flatten","Just","Nothing","of","_Just","val","_this","classCallCheck","_super","call","_val","concat","_super2","TypeError","other","Either","join","isRight","leftFn","rightFn","cata","None","Error","Left","Right","result","e","_asyncChain","_Right","asyncToGenerator","regeneratorRuntime","mark","_callee","wrap","_context","prev","next","abrupt","sent","stop","_Left","_this2","IO","effect","_effect","every","associate","prop","c","altAssoc","assoc","init","reduce","sum","acc","Number","a","b","toConsumableArray","deviation","usePopulation","mean","Math","sqrt","pow","difference","s","Set","filter","has","index$g","func","each","forEach","find","index$f","findIndex","curr","index$e","index$d","index$c","sep","index$b","index$a","assign","index$9","index$8","index$7","reduceRight","select","split","slice","start","end","some","index$3","sort","index$2","sA","sB","index$1","from","index","nums","Boolean","fns","n","isNaN","parseFloat","isFinite","partialArgs","_len2","remainingArgs","_key2","Promise","resolve","reject","err","reverse","_ref","carr","toArray","m","floor","random","_ref3"],"mappings":"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"}